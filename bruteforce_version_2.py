from csv_reader import extract_data_dictionary
from itertools import combinations
from time import perf_counter

def largest_possible_subset(actions):
    """
    We want to know what is the largest subset where the cheapest
    combination of stocks is permissible, i.e., under the threshold of 500 euros
    """
    # Create a sorted list of the prices of all stocks 
    # Organized from most to least expensive
    set = sorted([value[0] for value in actions.values()], reverse=True)
    # Working backwards from 
    for i in range(len(actions)):
        if sum(set[i:]) > 500:
            continue
        else:
            return len(actions) - i
        
def largest_size_all_under_500(actions):
    """
    We want to know which is the largest size of subset where all possible
    combinations are permissible, i.e., under the threshold of 500 euros
    """
    set = sorted([value[0] for value in actions.values()])
    for i in range(len(actions)):
        if sum(set[i:]) > 500:
            continue
        else:
            return len(actions) - i

        
def get_portfolio_return(portfolio):
    # Calculate the return on a given portfolio (dictionary)
    return round(sum([value[2] for value in portfolio.values()]), 2)

def get_portfolio_cost(portfolio):
    # Calculate the cost of a given portfolio (dictionary)
    return round(sum([value[0] for value in portfolio.values()]), 2)
    
def candidate_portfolios(combined_keys, actions):
    # This is the function that takes combinations of stock keys that have been 
    # generated by itertools and sorts them, returning dictionaries
    # that match the price criterion
    candidates = []
    for candidate in combined_keys:
        portfolio = {}
        for stock in candidate:
            # For each combination of stock names, we need to reconstruct 
            # its original dictionary
            price = actions[stock][0]
            gain = actions[stock][1]
            realised_gain = actions[stock][2]
            portfolio[stock] = (price, gain, realised_gain)
        # If the cost is under 500, it can be returned so that its
        # total return can be checked and compared
        if get_portfolio_cost(portfolio) < 500:
            candidates.append(portfolio)
    return candidates

def best_portfolio(candidates):
    # Takes a list of dictionaries, identifies their returns, and then returns
    # the one with the highest return
    all_portfolio_gains = []
    for i, portfolio in enumerate(candidates):
        total_gains = get_portfolio_return(portfolio)
        # we create a list of all the different returns, with an index
        # to link it to its original dictionary
        all_portfolio_gains.append((i, total_gains))
    # sort the list via the returns
    # and return the relevant dictionary
    highest_return = sorted(all_portfolio_gains, key=lambda x: x[1], reverse=True)
    return candidates[highest_return[0][0]]

def find_best_portfolio(actions, subset_max, subset_min):
    best_portfolios = []
    for i in range(subset_min, subset_max + 1):
        print(i)
        # This line uses itertools to generate all unique combinations of keys
        # for each length of subset
        combined_keys = list(combinations(actions.keys(), i))
        # This function reconstructs the dictionaries from the key combinations
        # and checks if they are too expensive
        candidates = candidate_portfolios(combined_keys, actions)
        # From the returned dictionaries that meet price criterion, this function
        # checks which is the most valuable
        # As we will sometimes not receive any valid candidates, the loop
        # has to continue in such a case
        if not candidates:
            continue
        best = best_portfolio(candidates)
        # This list keeps the best portfolio for each subset size 
        # for final comparison
        best_portfolios.append(best)
    # Once the best portfolio has been identified for each subset size,
    # we can compare all of them and return the best
    overall_best = best_portfolio(best_portfolios)
    return overall_best

def main():
    t1_start = perf_counter()

    actions = extract_data_dictionary('list-dactions.csv')
    subset_max = largest_possible_subset(actions)
    subset_min = largest_size_all_under_500(actions)

    best_combination = find_best_portfolio(actions, subset_max, subset_min) 
    best_return = get_portfolio_return(best_combination)
    best_cost = get_portfolio_cost(best_combination)

    t1_stop = perf_counter()
    
    print("Name: Price / Percentage / Actual return")
    for key, value in best_combination.items():
        print(f"{key}: {value[0], value[1], value[2]}")
    print(f"Total cost: {best_cost}")
    print(f"Total return: {best_return}")
    print(f"Elapsed time: {t1_stop-t1_start}")

if __name__ == "__main__":
    main()