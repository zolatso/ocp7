from csv_reader import extract_data_dictionary
from itertools import combinations
from time import perf_counter

def get_portfolio_return(portfolio):
    # Calculate the return on a given portfolio (dictionary)
    return round(sum([value[2] for value in portfolio.values()]), 2)

def get_portfolio_cost(portfolio):
    # Calculate the cost of a given portfolio (dictionary)
    return round(sum([value[0] for value in portfolio.values()]), 2)
    
def candidate_portfolios(combined_keys, actions):
    # This is the function that takes combinations of stock keys that have been 
    # generated by itertools and sorts them, returning dictionaries
    # that match the price criterion
    candidates = []
    for candidate in combined_keys:
        # For each combination of stock names, we need to reconstruct 
        # its original dictionary
        portfolio = {}
        for stock in candidate:
            price = actions[stock][0]
            gain = actions[stock][1]
            realised_gain = actions[stock][2]
            portfolio[stock] = (price, gain, realised_gain)
        # If the cost is under 500, it can be returned so that its
        # total return can be checked and compared
        if get_portfolio_cost(portfolio) < 500:
            candidates.append(portfolio)
    return candidates

def best_portfolio(candidates):
    # Takes a list of dictionaries, identifies their returns, and then returns
    # the one with the highest return
    all_portfolio_gains = []
    for i, portfolio in enumerate(candidates):
        total_gains = get_portfolio_return(portfolio)
        # we create a list of all the different returns, with an index
        # to link it to its original dictionary
        all_portfolio_gains.append((i, total_gains))
    # sort the list via the returns
    # and return the relevant dictionary
    highest_return = sorted(all_portfolio_gains, key=lambda x: x[1], reverse=True)
    return candidates[highest_return[0][0]]

def find_best_portfolio(actions):
    best_portfolios = []
    subset_size = len(actions)
    for i in range(subset_size):
        print(i + 1)
        # This line uses itertools to generate all unique combinations of keys
        # for each length of subset
        combined_keys = list(combinations(actions.keys(), subset_size - i))
        # This function reconstructs the dictionaries from the key combinations
        # and checks if they are too expensive
        candidates = candidate_portfolios(combined_keys, actions)
        # From the returned dictionaries that meet price criterion, this function
        # checks which is the most valuable
        # As we will sometimes not receive any valid candidates, the loop
        # has to continue in such a case
        if not candidates:
            continue
        best = best_portfolio(candidates)
        # This list keeps the best portfolio for each subset size 
        # for final comparison
        best_portfolios.append(best)
    # Once the best portfolio has been identified for each subset size,
    # we can compare all of them and return the best
    overall_best = best_portfolio(best_portfolios)
    return overall_best

def main():
    t1_start = perf_counter()
    actions = extract_data_dictionary('list-dactions.csv')
    # subset_size = largest_possible_subset(actions)
    
    best_combination = find_best_portfolio(actions) 
    best_return = get_portfolio_return(best_combination)
    best_cost = get_portfolio_cost(best_combination)
    t1_stop = perf_counter()

    print("Name: Price / Percentage / Actual return")
    for key, value in best_combination.items():
        print(f"{key}: {value[0], value[1], value[2]}")
    print(f"Total cost: {best_cost}")
    print(f"Total return: {best_return}")
    print(f"Elapsed time: {t1_stop-t1_start}")


if __name__ == "__main__":
    main()